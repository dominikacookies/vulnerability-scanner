import os
import datetime
import time
import threading
import uuid
import csv
from typing import Dict, List
from constants.constants import FILE_LIST_PATH
from worker_agent import WorkerAgent


class LeaderAgent:
    def __init__(self, search_dir: str, process_id: str):
        """
        Initialise LeaderAgent

        Args:
            search_dir (str): path to directory of files to be scanned
        """
        self.search_dir = search_dir
        self.workers: Dict[str, WorkerAgent] = {}
        self.process_id = process_id
        self.quarantine_dir = f'./{process_id}/quarantine'
        self.teminated_worker_logs = []
        self.terminated_worker_paths = []
        self.safe_files = 0
        self.amber_quarantine_files = 0
        self.red_quarantine_files = 0

    def get_all_file_paths(self, directory: str) -> List[str]:
        """
        Get all the file paths within the provided directory.

        Args:
        directory (str): the directory path to search for files.

        Returns:
            List[str]: list of file paths.
        """
        file_paths = []
        for root, _, files in os.walk(directory):
            for filename in files:
                file_path = os.path.join(root, filename)
                file_paths.append(file_path)
        return file_paths

    def initalise_scanning_environment(self):
        """
        Initialise the environment for workers by generating a list of file paths
        to scan and setting up the qaurantine directory.
        """

        file_paths = self.get_all_file_paths(self.search_dir)
        with open(FILE_LIST_PATH, 'w') as files_list_file:
            for file_path in file_paths:
                files_list_file.write(file_path + "\n")
        os.makedirs(f'./{self.process_id}', exist_ok=True)
        os.makedirs(self.quarantine_dir, exist_ok=True)

    def add_worker(self, worker: WorkerAgent):
        """
        Add a worker agent to list of workers.

        Args:
            worker (WorkerAgent): the worker agent to be added.
        """
        self.workers[worker.agent_id] = worker
        

    def agent_recently_active(self, file_path: str) -> bool:
        """
        Check if an agent has been active in the last 60secs by inspecting its log file.

        Args:
            file_path (str): path to the agent's log file

        Returns:
            bool: True if the agent has been recently active, False if it hasn't.
        """
        try:
            with open(file_path, 'r') as file:
                lines = file.readlines()
                if lines:
                    last_line = lines[-1]
                    timestamp_str = last_line.split(
                        '|')[0].strip('Timestamp: ')
                    timestamp = datetime.datetime.strptime(
                        timestamp_str, "%Y-%m-%d %H:%M:%S.%f")
                    current_time = datetime.datetime.now()
                    time_diff = current_time - timestamp
                    return time_diff.total_seconds() <= 60
                return False
        except FileNotFoundError:
            return False
        except Exception:
            return False

    def poll_agent_log_files(self):
        """
        Check worker log files every minute. If a worker has hung up, terminate it and start a new one.
        """
        active_workers = []
        for worker in self.workers.values():
            if self.agent_recently_active(worker.log_file_path):
                active_workers.append(worker)
            else:
                self.terminate_worker(worker)
                worker_thread = threading.Thread(target=self.start_worker)
                worker_thread.start()
        self.workers = active_workers
        time.sleep(60)

    def terminate_worker(self, worker: WorkerAgent):
        """
        Terminate a worker agent and print its current file path.

        Args:
            worker (WorkerAgent): The worker agent to be killed.
        """
        try:
            current_file_path = worker.get_current_file()
            if current_file_path:
                self.terminated_worker_paths.append(current_file_path)
            self.teminated_worker_logs.append(worker.log_file_path)
            del self.workers[worker.agent_id]
            del worker
        except Exception as e:
            print(f"An error occurred while terminating worker {worker.get_id()}: {e}")

    def start_worker(self):
        """
        Create a new worker agent and add it to the list of workers.
        """
        agent_uuid = uuid.uuid4()
        worker = WorkerAgent(agent_uuid, self)
        self.add_worker(worker)
        worker_thread = threading.Thread(target=worker.scan_files)
        worker_thread.start()

    def get_workers(self) -> Dict[str, WorkerAgent]:
        """
        Get all of the worker agents.

        Returns:
            Dict[str, WorkerAgent]: a dictionary of worker agents.
        """
        return self.workers

    def update_scanning_results(self, result):
        """
        Update the total number of safe, amber and red files identified.

        Args:
            result (str): Scanning result for a file ('SAFE', 'AMBER', or 'RED').
        """
                
        if result == 'SAFE':
            self.safe_files = self.safe_files+1
        if result == 'AMBER':
            self.amber_quarantine_files = self.amber_quarantine_files+1
        if result == 'RED':
            self.red_quarantine_files = self.red_quarantine_files+1

    def generate_report(self):
        """
        Generate the reports, one containing a summary of the findings. 
        The second a CSV file with the outcomes of each file scan.
        """
        summary_report = open(f'./{self.process_id}/report-summary.txt', 'x')
        summary_report.write(f'Scanning complete. Found:\n- {self.safe_files} safe files,\n- {self.amber_quarantine_files} files with a potential secret or key\n- and {self.red_quarantine_files} files with a common file extension for secrets or keys\nThe following files could not be inspected due to an error: {self.terminated_worker_paths}')
        summary_report.close()

        with open(f'./{self.process_id}/report.csv', "x") as report_file:
            writer = csv.writer(report_file)
            writer.writerow(['Timestamp', 'File', 'Quarantine Status', 'Result'])

            for log_file_path in self.teminated_worker_logs:
                with open(log_file_path, 'r') as log_file:
                    log_contents = csv.reader(log_file)
                    writer.writerows(log_contents)
                    log_file.close()
                os.remove(log_file_path)
                
        os.remove(FILE_LIST_PATH)

