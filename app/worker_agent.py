import os
import shutil
import datetime
import filelock
import time
import re
import csv
from typing import Optional, List, Union
# from leader_agent import LeaderAgent

from constants.constants import FILE_LIST_PATH
from utils.secret_pattern_analysers import is_base64_string, is_long_random_string, is_uuid_or_guid, is_hex_string

amber_file_extensions = ['.json', '.txt', '.env', '.log', '.md',
                         '.rst', '.xml', '.config', '.properties', '.yaml', '.toml']
red_file_extensions = ['.key', '.pem', '.pfx', '.p12',
                       '.jks', '.keystore', '.cer', '.crt', '.der', '.ppk', '.ssh']
secret_phrases = ['BEGIN PRIVATE KEY', 'BEGIN RSA PRIVATE KEY',
                  'BEGIN EC PRIVATE KEY', 'BEGIN OPENSSH PRIVATE KEY', 'BEGIN PGP PRIVATE KEY BLOCK']


class WorkerAgent:
    def __init__(self, agent_id: int, leader, process_id: str) -> None:
        """
        Initialise WorkerAgent.

        Args:
            agent_id (int): worker agent id
            leader: leader agent object
        """

        self.agent_id = agent_id
        self.process_id = process_id
        self.current_file = None
        self.leader = leader
        self.log_file_path = f'./{process_id}/{agent_id}-log.csv'
        open(self.log_file_path, "x")

    def get_file_path_to_scan(self) -> Optional[str]:
        """
        Get the top file path from the list of files to scan.

        Returns:
            Optional[str]: file path from the list or None if list is empty.
        """
        try:
            with filelock.FileLock(f"{FILE_LIST_PATH}.lock") as file_lock:
                file_lock.acquire(timeout=0)
                with open(FILE_LIST_PATH, 'r+') as path_list_file:
                    lines = path_list_file.readlines()
                    if lines:
                        first_line = lines[0].rstrip('\n')
                        lines = lines[1:]
                        path_list_file.seek(0)
                        path_list_file.writelines(lines)
                        path_list_file.truncate()
                        return first_line
                return None
        except filelock.Timeout:
            print("File is locked. Waiting for 30ms...")
            time.sleep(0.03)  # wait 30ms before trying again
        except Exception as e:
            print(f"An error occurred: {e}")

    def quarantine_file(self) -> None:
        """
        Move current file to quarantine directory.
        """
        try:
            file_name = os.path.basename(self.current_file)
            new_file_path = os.path.join(
                f'./{self.process_id}/quarantine', file_name)
            shutil.move(self.current_file, new_file_path)
        except Exception as e:
            print(f"Error moving file '{file_name}': {e}")

    def contains_exposed_keys_or_secrets(self) -> Union[bool, List[str]]:
        """
        Check the file content for potential private key patterns or secret phrases

        Returns:
            Union[bool, List[str]]: list of potential private key patterns or secret phrases or False if none found
        """
        try:
            with open(self.current_file, 'r') as file:
                content = file.read()
                potential_secrets = []

                for secret_phrase in secret_phrases:
                    if secret_phrase in content:
                        potential_secrets.append(
                            f'SECRET PHRASE: {secret_phrase},')

                long_random_strings = [f'LONG RANDOM STRING: {value},' for value in re.findall(
                    r'[\w/+]{32}', content) if is_long_random_string(value)]
                potential_secrets.extend(long_random_strings)

                uuids_guids = [f'UUID OR GUID: {value},' for value in re.findall(
                    r'[a-f0-9]{8}-?[a-f0-9]{4}-?[a-f0-9]{4}-?[a-f0-9]{4}-?[a-f0-9]{12}', content, re.IGNORECASE) if is_uuid_or_guid(value)]
                potential_secrets.extend(uuids_guids)

                base64_strings = [f'BASE64 STRING: {value},' for value in re.findall(
                    r'[A-Za-z0-9+/=]{24,}', content) if is_base64_string(value)]
                potential_secrets.extend(base64_strings)

                hex_strings = [f'HEX STRING: {value},' for value in re.findall(
                    r'0x[a-fA-F0-9]{16,}', content) if is_hex_string(value)]
                potential_secrets.extend(hex_strings)
                print('shhhh', potential_secrets)
                return potential_secrets if potential_secrets else False

        except FileNotFoundError:
            print(f"File not found: {self.current_file}")
            return False
        except Exception as e:
            print(f"An error occurred: {e}")
            return False
    # to do add outcome none type

    def update_log_file(self, quarantine_status: str, outcome: str) -> None:
        """
        Update log file with the scanning outcome

        Args:
            scanned_file (str): path of the scanned file
            outcome (str): outcome of the scan
        """

        try:
            with open(self.log_file_path, 'a', newline='') as csvfile:
                current_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")
                writer = csv.writer(csvfile)
                writer.writerow([current_time, self.current_file,
                                quarantine_status, outcome])
        except FileNotFoundError:
            print(f"File not found: {self.log_file_path}")
        except Exception as e:
            print(f"An error occurred: {e}")

    def get_current_file(self) -> Optional[str]:
        """
        Get the path of the current file being scanned.

        Returns:
            Optional[str]: Path of the current file being scanned, or None if no file is being scanned.
        """
        return self.current_file

    def get_id(self) -> int:
        """
        Get the identifier of the worker agent.

        Returns:
            int: Identifier of the worker agent.
        """
        return self.agent_id

    def scan_files(self) -> bool:
        """
        Scan files for potential security issues.

        Returns:
            bool: True if scanning is successful, False otherwise.
        """
        quarantine_status = 'SAFE'
        outcome = None

        if self.current_file:
            if os.path.splitext(self.current_file)[-1].lower() in red_file_extensions:
                self.quarantine_file()
                outcome = 'File extension is known for commonly holding keys and secrets'
                quarantine_status = 'RED'
            elif os.path.splitext(self.current_file)[-1].lower() in amber_file_extensions:
                amber_check_result = self.contains_exposed_keys_or_secrets()
                if amber_check_result:
                    self.quarantine_file()
                    outcome = f'Found the following secret phrases and/or potential values: {amber_check_result}'
                    quarantine_status = 'AMBER'
            
            self.leader.update_scanning_results(quarantine_status)
            self.update_log_file(quarantine_status, outcome)
            return True
        else:
            self.current_file = None
            self.leader.terminate_worker(self)
            return False
