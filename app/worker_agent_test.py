import unittest
from unittest.mock import MagicMock, patch, mock_open
from worker_agent import WorkerAgent
import filelock


class TestWorkerAgent(unittest.TestCase):
    def setUp(self):
        self.agent_id = "1a2b3cdee"
        self.leader = MagicMock()
        self.process_id = "1a2b3cdee"
        self.log_file_path = f'./{self.process_id}/{self.agent_id}-log.csv'
        self.file_list_path = f'./{self.process_id}/file-paths.txt'

        with patch("builtins.open", mock_open()):
            self.worker_agent = WorkerAgent(
                self.agent_id, self.leader, self.process_id)

    def test_worker_agent_initialization(self):
        self.assertEqual(self.worker_agent.agent_id, self.agent_id)
        self.assertEqual(self.worker_agent.process_id, self.process_id)
        self.assertIsNone(self.worker_agent.current_file)
        self.assertEqual(self.worker_agent.leader, self.leader)
        self.assertEqual(self.worker_agent.log_file_path, self.log_file_path)

    @patch('worker_agent.filelock.FileLock')
    def test_get_file_path_to_scan_returns_string(self, mocked_file_lock):
        with patch('builtins.open', mock_open(read_data="file1.txt\nfile2.txt\nfile3.txt")) as mocked_open:
            result = self.worker_agent.get_file_path_to_scan()

            mocked_file_lock.assert_called_with(f"{self.file_list_path}.lock")
            mocked_open.assert_called_with(self.file_list_path, 'r+')

            self.assertEqual(result, 'file1.txt')

    @patch('worker_agent.filelock.FileLock')
    def test_get_file_path_to_scan_returns_none_when_empty(self, mocked_file_lock):
        with patch('builtins.open', mock_open(read_data="")) as mocked_open:
            result = self.worker_agent.get_file_path_to_scan()

            mocked_file_lock.assert_called_with(f"{self.file_list_path}.lock")
            mocked_open.assert_called_with(self.file_list_path, 'r+')

            self.assertIsNone(result)

    @patch('builtins.print')
    @patch('worker_agent.filelock.FileLock')
    @patch('worker_agent.time')
    def test_get_file_path_to_scan_timeout_on_filelock(self, mock_time, mocked_file_lock, print_mock):
        mocked_lock_instance = MagicMock()
        mocked_lock_instance.acquire.side_effect = filelock.Timeout("timeout")
        mocked_file_lock.return_value.__enter__.return_value = mocked_lock_instance

        self.worker_agent.get_file_path_to_scan()

        mock_time.sleep.assert_called_with(0.03)
        print_mock.assert_called_with("File is locked. Waiting for 30ms...")

    def test_get_file_path_to_scan_handle_exception(self):
        with patch('worker_agent.filelock.FileLock') as mocked_file_lock:
            mock_lock_instance = MagicMock()
            mock_lock_instance.acquire.return_value = True
            mocked_file_lock.return_value.__enter__.side_effect = Exception(
                "Test exception")

            # with self.assertLogs() as cm:
            #     self.worker_agent.get_file_path_to_scan()
            #     self.assertEqual(cm.output, [f"An error occurred: Test exception"])
            #     # elf.assertEqual(cm.output, ['File is locked. Waiting for 30ms...'])
    @patch('worker_agent.os.path.basename')
    @patch('worker_agent.os.path.join')
    @patch('worker_agent.shutil.move')
    def test_quarantine_file(self, shutil_move_mock, os_path_join_mock, os_path_basename_mock):
        mock_basename_path = "base_path"
        mock_join_path = "join-path"
        self.worker_agent.current_file = "my_file.txt"
        os_path_basename_mock.return_value = mock_basename_path
        os_path_join_mock.return_value = mock_join_path

        self.worker_agent.quarantine_file()

        os_path_basename_mock.assert_called_with(
            self.worker_agent.current_file)
        os_path_join_mock.assert_called_with(
            f'./{self.worker_agent.process_id}/quarantine', mock_basename_path)
        shutil_move_mock.assert_called_with(
            self.worker_agent.current_file, mock_join_path)

    @patch('builtins.print')
    def test_quarantine_file_exception(self, print_mock):
        self.worker_agent.current_file = "my_file.txt"
        self.worker_agent.quarantine_file()
        print_mock.assert_called_once()

    @patch('builtins.open', mock_open(read_data="file1.txt\nfile2.txt\nfile3.txt"))
    def contains_exposed_keys_or_secrets(self, mocked_open):
        self.worker_agent.current_file = "my_file.txt"
        mocked_open.assert_called_with(self.worker_agent.current_file, 'r')

    @patch('worker_agent.open', mock_open(read_data='test content'))
    def test_contains_exposed_keys_or_secrets_no_secrets(self):
        self.worker_agent.current_file = 'test_file.txt'
        secrets = self.worker_agent.contains_exposed_keys_or_secrets()
        self.assertFalse(secrets)

    @patch('worker_agent.open', mock_open(read_data='test content secret_phrase BEGIN PRIVATE KEY LONG_RANDOM_STRING_1234 01234567-89AB-CDEF-0123-456789ABCDEF base64_string ABCDEFGHIJKLMNOPQRSTUVWXYZ+/== hex_string 0x0123456789ABCDEF'))
    def test_contains_exposed_keys_or_secrets(self):
        self.worker_agent.current_file = 'test_file.txt'
        secrets = self.worker_agent.contains_exposed_keys_or_secrets()
        expected_secrets = ['SECRET PHRASE: BEGIN PRIVATE KEY,', 'UUID OR GUID: 01234567-89AB-CDEF-0123-456789ABCDEF,',
                            'BASE64 STRING: ABCDEFGHIJKLMNOPQRSTUVWXYZ+/==,', 'HEX STRING: 0x0123456789ABCDEF,']
        self.assertEqual(secrets, expected_secrets)

    @patch('worker_agent.open', mock_open())
    @patch('worker_agent.datetime')
    @patch('worker_agent.csv')
    def test_update_log_file(self, mock_csv, mock_datetime):
        mock_now = MagicMock()
        mock_now.strftime.return_value = '2024-05-14 12:00:00.000000'
        mock_datetime.datetime.now.return_value = mock_now

        self.worker_agent.current_file = 'test_file.txt'
        self.worker_agent.log_file_path = 'test_log.csv'

        self.worker_agent.update_log_file('SAFE', 'No issues found')

        mock_now.strftime.assert_called_once_with("%Y-%m-%d %H:%M:%S.%f")

        mock_csv.writer.return_value.writerow.assert_called_once_with(
            ['2024-05-14 12:00:00.000000', 'test_file.txt', 'SAFE', 'No issues found'])

    def test_get_current_file(self):
        self.worker_agent.current_file = 'test_file.txt'

        self.assertEqual(self.worker_agent.get_current_file(), 'test_file.txt')

    def test_get_id(self):
        self.worker_agent.agent_id = 123

        self.assertEqual(self.worker_agent.get_id(), 123)

    @patch('worker_agent.WorkerAgent.quarantine_file')
    @patch('worker_agent.WorkerAgent.update_log_file')
    def test_scan_files_safe_file(self, mock_update_log_file, mock_quarantine_file):
        self.worker_agent.current_file = 'test_file.js'

        result = self.worker_agent.scan_files()

        mock_quarantine_file.assert_not_called()
        mock_update_log_file.assert_called_once_with(
            'SAFE', None)
        self.worker_agent.leader.update_scanning_results.assert_called_once_with(
            'SAFE')
        self.assertTrue(result)


    @patch('worker_agent.WorkerAgent.quarantine_file')
    @patch('worker_agent.WorkerAgent.update_log_file')
    def test_scan_files_red_file(self, mock_update_log_file, mock_quarantine_file):
        self.worker_agent.current_file = 'test_file.key'

        self.worker_agent.scan_files()

        mock_quarantine_file.assert_called_once()
        mock_update_log_file.assert_called_once_with(
            'RED', 'File extension is known for commonly holding keys and secrets')
        self.worker_agent.leader.update_scanning_results.assert_called_once_with(
            'RED')
        
    @patch('worker_agent.WorkerAgent.quarantine_file')
    @patch('worker_agent.WorkerAgent.contains_exposed_keys_or_secrets')
    @patch('worker_agent.WorkerAgent.update_log_file')
    def test_scan_files_amber_file_safe(self, mock_update_log_file, mock_contains_secrets, mock_quarantine_file):
        self.worker_agent.current_file = 'test_file.txt'
        mock_contains_secrets.return_value = False

        self.worker_agent.scan_files()

        mock_quarantine_file.assert_not_called()
        mock_update_log_file.assert_called_once_with(
            'SAFE', None)
        self.worker_agent.leader.update_scanning_results.assert_called_once_with(
            'SAFE')
        
    @patch('worker_agent.WorkerAgent.quarantine_file')
    @patch('worker_agent.WorkerAgent.contains_exposed_keys_or_secrets')
    @patch('worker_agent.WorkerAgent.update_log_file')
    def test_scan_files_amber_file_unsafe(self, mock_update_log_file, mock_contains_secrets, mock_quarantine_file):
        self.worker_agent.current_file = 'test_file.txt'
        found_secrets = ["danger"]
        mock_contains_secrets.return_value = found_secrets

        self.worker_agent.scan_files()

        mock_quarantine_file.assert_called()
        mock_update_log_file.assert_called_once_with(
            'AMBER', f"Found the following secret phrases and/or potential values: {found_secrets}")
        self.worker_agent.leader.update_scanning_results.assert_called_once_with(
            'AMBER')
    
    @patch('worker_agent.WorkerAgent.quarantine_file')
    def test_scan_files_no_current_file(self, mock_quarantine_file):
        result = self.worker_agent.scan_files()

        mock_quarantine_file.assert_not_called()
        self.worker_agent.leader.update_scanning_results.assert_not_called()
        self.worker_agent.leader.terminate_worker.assert_called()
        self.assertFalse(result)

if __name__ == "__main__":
    unittest.main()
